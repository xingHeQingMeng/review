/**
 * 垃圾回收是动态存储管理技术，
 * 会自动地释放‘垃圾’（不再被程序引用的对象）
 * 按照特定的拉埃及收集算法来实现资源自动回收的功能
 * 回收的两种机制：
 *  1. 标记清楚
 *  2. 引用计数 垃圾回收器会按照固定的世纪那间隔周期的执行
 *
 */

// 标记清除
/**
 * 标记清除分为：标记阶段和清除阶段
 * 首先他会遍历堆内存上所有的对象，分别给他们打上标记，
 * 然后在大妈执行过程结束之后，对所使用过的变量取消标记。
 * 在清除阶段再把具有标记的内存对象进行整体清除
 * 从而释放内存空间
 *
 * 垃圾收集器在运行时会给内存中所有的变量都加上一个标记
 * 热案后从各个根对象开始遍历，把还在被上下文引用的变量去掉标记
 * 清理所有带有标记的变量，销毁并回收他们所占用的空间
 * 最后垃圾回收程序做一次内存清理
 *
 * 优点：
 *  简单，无非是标记不标记的差异。
 * 缺点：
 *  经过标记清除后，剩余的对象内存位置是不变的，
 *  会导致空闲内存空间是不连续的，这就曹诚出现内存碎片的问题。
 *  内存碎片多了之后，如果要储存一个新的需要占据较大内存空间的对象，
 *  就会造成影响。
 *  对于通过标记清除产生的内存碎片，还是需要通过标记整理策略进行解决
 * 简而言之：
 *  优点：简单
 *  缺点：内存碎片化，分配速度慢
 */

// 标记整理
/**
 * 可以有效解决标记清楚的两个缺点。
 * 在标记和清除阶段和标记清除算法没有什么不同，
 * 只是在标记结束后，标记整理算法会将活着的对象（不需要清理）向内存的一端移动，最后清理掉边界的内存
 */

// 引用计数
/**
 * 引用计数是一种不常见的垃圾回收策略
 * 其思路就是对每个值都记录其引用次数。
 *  - 当变量进行声明赋值后，值得引用数为1
 *  - 当同一个值被赋值给另一个变量时，引用数 +1
 *  - 当保存该值引用的变量被其他值覆盖时，引用数 - 1
 *  - 当该值的引用数为 0 时，表示无法在访问该值了，此时就可以放心的将其清除并回收内存
 *
 * 缺点：
 *  循环引用时会出现问题，造成大量的内存不会被释放
 */
